Шаг 1. Перенос модели
Для начала перенесем модель интернет-магазина в Spring. Как вы помните, у нас было две сущности — абстрактный Товар (
Product
) и Статья (
Article
). У товара было три класса-потомка. Также мы создавали интерфейс
Searchable
, чтобы пользоваться поиском с помощью поискового движка

Начните с создания пакета
model
, в который мы будем переносить эти классы. Этот пакет нужно создать в корневом пакете приложения.

Далее перенесите по очереди следующие классы:

Интерфейс
Searchable
— для него нужно будет создать пакет
model.search
.
Классы товаров
Product
— в пакет
model.product
.
Класс статьи
Article
— в пакет
model.article
.
После этого проверьте, что проект компилируется.

Пока никакой функциональности мы не перенесли, поэтому запросы через браузер ничего не дадут.

Шаг 2. Добавления идентификаторов
В веб-приложениях принято, что каждая сущность имеет идентификатор — для быстрого доступа к себе. Обычно эти идентификаторы представляют некоторые числовые значения или UUID — специальный вид уникального идентификатора.

В проекте используйте UUID в качестве идентификаторов.

Для начала добавим к нашим сущностям идентификаторы:

В интерфейс
Searchable
добавьте метод
getId()
, который возвращает
UUID(java.util.UUID)
.
Реализуйте этот метод в классах
Article
и
Product
. Для этого в них нужно:
Завести
private final
-поле с типом
UUID
, которое называется
id
.
Добавить геттер для этого поля. После добавления геттера эти классы начнут реализовывать интерфейс
Searchable
.
Сами поля
id
нужно принимать в конструкторе, модифицируя его и добавив поле
id
в список параметров конструктора.

В случае с
Product
добавьте поле
id
в конструкторы всех классов-потомков, так как конструкторы не наследуются.
Шаг 3. Добавления сервиса хранения
До этого этапа  у нас не было отдельного сервиса хранения продуктов и статей, так как мы создавали их в методе
main
— только для демонстрации.

Но в веб-приложения, чтобы обращаться к нашим сущностям, нам нужно хранить их где-то в памяти. Для этого нужно написать сервис для хранения.

Создайте класс
StorageService
в пакете
service
. Этот класс должен содержать в себе две
private final
:
Map<UUID, Product>
— хранилище продуктов,
Map<UUID,Article>
— хранилище статей.
Данный
Map
нужно создавать в конструкторе класса
StorageService
.
Напишите два метода:
возвращающий коллекцию всех статей,
возвращающий коллекцию всех продуктов.
В конструкторе сервиса заполните эти мапы тестовыми данными из метода
main
нашего предыдущего проекта. Для этого лучше всего сделать отдельный приватный метод и вызывать его в конструкторе. Помните: теперь нужно добавлять всем объектам идентификаторы. Это можно сделать с помощью метода
UUID.randomUuid()
.
Добавьте над классом
StorageService
аннотацию
@Service
, чтобы Spring мог зарегистрировать его как управляемый объект и предоставлять этот класс другим классам.
Шаг 4. Добавление контроллера
Теперь выведем содержимое
StorageService
в браузер.

Для этого создайте класс контроллера
ShopController
в пакете
controller
. Этот класс должен обращаться к сервису
StorageService
и получать продукты и статьи.

Для этого создадим два метода, которые должны возвращать соответственно все продукты или все статьи, доступные в
StorageService
.

@GetMapping("/products")
public Collection<Product> getAllProducts()

@GetMapping("/articles")
public Collection<Article> getAllArticles()
Spring умный. Когда он увидит в возвращаемых аргументах класс, который не является строкой, то переведет его в специальный формат JSON (подробнее о нем мы поговорим в следующих уроках курса).

После добавления контроллера проверьте, что в браузере:

при открытии localhost:8080/products доступен список тестовых продуктов,
при открытии  localhost:8080/articles — список статей.
Возможно вы заметили, что в возвращаемых данных присутствуют строки
searchTerm
и
contentType
. Давайте сделаем так, чтобы они не выводились. Для этого добавьте аннотацию
@JsonIgnore
над методами геттерами
getSearchTerm
и
getContentType
в классах
Product
и
Article
соответственно.

Шаг 5. Восстановление функциональности поиска
Чтобы восстановить поиск выполните следующие действия:

Создайте новый класс
SearchResult
,  который будет моделью результата поиска. Добавьте в него строковые поля
id
,
name
и
contentType
. Класс должен быть неизменяемым (immutalbe). Это значит, что все поля должны иметь модификатор
final
и задаваться в конструкторе. Не забудьте поместить класс в нужный пакет.
Для простоты создания
SearchResult
из интерфейса
Searchable
напишите публичный статический метод
fromSearchable
внутри класса
SearchResult
. Метод должен принимать
Searchable
и возвращать
SearchResult
с заполненными полями.
Такой способ создания объектов называется статический фабричный метод. Он часто используется, чтобы инкапсулировать логику создания объекта в классе самого объекта.

Добавьте сервис поиска
SearchService
в пакет
service
. В этом сервисе будет много изменений, поэтому проще не переносить старый класс, а написать новый. В сервисе поиска нам нужно добавить сервис хранения (
StorageService
) как зависимость нашего
SearchService
и заставить спринг принести нам этот класс через конструктор. Для этого:
добавьте его как
private final
поле
и инициализируйте в конструкторе.
Не забудьте пометить
SearchService
как
@Service
с помощью аннотации.

Теперь сделайте так, чтобы сервис хранения (
StorageService
) умел возвращать нам коллекцию объектов типа
Searchable
, по которой мы сможем искать в
SearchService
. Для этого напишите в
StorageService
метод, который возвращает коллекцию
Searchable
путем объединения всех статей и всех продуктов в одну коллекцию внутри метода.
Напишем новый метод
search
в классе
SearchService
. Он должен принимать строку для поиска и возвращать коллекцию объектов
SearchResult
. Для написания метода воспользуйтесь Stream API. Сортировать результаты и дополнительно обрабатывать пока не надо.
Добавьте новый метод в контроллер. Это должен быть
@GET
-метод с путем
/search
. Он должен принимать аргумент
pattern
, который будет той самой строкой поиска. Метод должен возвращать коллекцию объектов
SearchResult
.
Если все выполнено правильно и по шагам, при запросе localhost:8080/search?pattern=<какая-то строка> вы получите результаты поиска или пустой список.